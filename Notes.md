- Any **API** is merely a collection of programs that an application can use to access other components of the operating system.
-  The IP address and port number concatenated together is called a **socket**.
- If you wanted to send HTTP data to a computer, it wouldn’t be enough to send it to the IP address; the computer does not inherently know which application is supposed to receive the data. 
- Therefore, we use sockets, which define the exact destination that the data should take: both the IP address of the receiving computer as well as the port on the computer which the receiving application is using. 
- The application would use the socket API of the operating system (via Ruby’s TCPSocket class) to open a passive connection, which notifies the operating system that the application is ready to receive connections through a particular port.
- Once it receives the request, what it does next is up to the code written in the application. The HTTP request will arrive as one very long string. 
- The entire content of the headers and the body will have to be parsed so that the application will be able to refer to specific headers, the request path, and the HTTP method, etc.
- For the code in the app to execute, the client will need to send an HTTP request to the socket on which the application is listening. 
- In local development, the developer’s web browser is the client. The host is named localhost, and the port number will be 4567. To send an HTTP request to localhost:4567, the developer just needs to enter localhost:4567 in my web browser.
- Once the application has parsed the HTTP request, it will perform whatever actions specified in the code, and will then have to return an HTTP-compliant response. That means returning the status, the headers, the body, all formatted properly as string data types.
- Once the application code formats the input that it received from the client, it will use that input in some way to accomplish “server-side” tasks. Once it accomplishes these tasks, it will send a response back to the client through port 4567 and to the particular socket (IP_of_client:port_number) through which the client is receiving information.
- In this case, instead of opening a TCP connection directly between our app and the socket, we could let a pre-built application make use of the socket API of the operating system.
- Application server:
  - contains code that allow it to parse HTTP information into Ruby data structures that make sense (e.g. turning HTTP request headers from text into hashes)
  - contains code that allows it to interface with a standard web server via socket connections (which utilize the `socket` API of the operating system)
  - contains code that captures the return value of your application and transforms the return value into HTTP-formatted text. It does all of this so that your application doesn’t have to.
- Rack Specification -> So ‘Rack’ is basically a *specification* of these two things: what the server should send to the app and what the app should return to the server. That’s it.
- Rack gives developers a consistent interface when working with Rack compatible servers, effectively giving web server developers and application framework developers a common language.
- Sinatra -> But at the core, it's nothing more than some Ruby code connecting to a TCP server, handling requests and sending back responses all in an HTTP-compliant string format. Keep that in mind.